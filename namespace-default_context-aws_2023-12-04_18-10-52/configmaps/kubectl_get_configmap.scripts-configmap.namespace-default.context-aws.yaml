apiVersion: v1
data:
  config_ranger.py: |
    #!/usr/bin/env python3
    import subprocess
    from argparse import ArgumentParser, Namespace
    from os import environ

    import logging
    import requests
    import yaml
    from sys import stdout
    from typing import Any, Dict, List

    SERVICE_DEFINITION: str = "starburst-enterprise"

    RANGER_PROTOCOL: str = "http://"
    RANGER_PORT: str = environ["RANGER__policymgr_port"].lower()
    try:
        if environ["RANGER__policymgr_http_enabled"].lower() == "false":
            RANGER_PROTOCOL = "https://"
    except KeyError:
        print("Environment variable RANGER__policymgr_http_enabled is not defined!")

    RANGER_ADDRESS: str = f"{RANGER_PROTOCOL}localhost:{RANGER_PORT}"
    print("Ranger_address: " + RANGER_ADDRESS)


    def read_manifest(path: str) -> Any:
        with open(path, "rb") as manifest:
            return yaml.load(manifest, Loader=yaml.SafeLoader)


    def find_by_name(items: List[Dict[str, Any]], item_name: str) -> Dict[str, Any]:
        matching = list(filter(lambda item: item["name"] == item_name, items))
        assert (
                len(matching) == 1
        ), "Expected 1 item with name '{}', found {}".format(
            item_name, len(matching)
        )
        return matching[0]


    def create_user(username: str, password: str) -> None:
        admin_user = "admin"
        admin_password = environ["RANGER__rangerAdmin_password"]
        if admin_user == username and admin_password != password:
            message = (f"Datasource password for \"{username}\" is not equal to "
                       f"\"{admin_user}\" password. When using \"{admin_user}\" "
                       f"as a datasource user it has to have the same password "
                       f"as the admin.passwords.admin property defined in Helm values file or "
                       f"the RANGER__rangerAdmin_password environmental variable.")
            raise RuntimeError(message)
        elif admin_user == username:
            return
        else:
            # if refactoring to Python request, take additional time as
            # post() method constantly returns 404 for create_user()
            subprocess.check_call(
                [
                    "./create-user.sh",
                    "-l", RANGER_ADDRESS,
                    "-u", admin_user,
                    "-p", admin_password,
                    username,
                    password,
                ],
                cwd="/scripts"
            )


    def create_service_definition(username: str, password: str) -> None:
        subprocess.check_call(
            [
                "./create-service-def.py",
                "--url", RANGER_ADDRESS,
                "--username", username,
                "--password", password,
            ],
            cwd=environ["RANGER_BASE"]
        )


    def get_service(username: str, password: str, service_name: str) -> Any:
        logging.info("Getting service [%s]", service_name)
        response: requests.models.Response = requests.get(
            url=RANGER_ADDRESS + "/service/public/v2/api/service/name/" + service_name,
            auth=(username, password),
            verify=False
        )
        assert (response.status_code in (200, 404)
                ), "Incorrect response while getting service: " + response.text
        if response.status_code == 404:
            return {}
        return response.json()


    def create_or_update_service(
            coordinator_url: str,
            username: str,
            password: str,
            starburst_password: str,
            common_name_4_cert: str,
            service_name: str) -> None:
        service: Dict[str, Any] = get_service(username, password, service_name)
        if service:
            update_service(coordinator_url,
                           username,
                           password,
                           starburst_password,
                           common_name_4_cert,
                           service)
        else:
            create_service(coordinator_url,
                           username,
                           password,
                           starburst_password,
                           common_name_4_cert,
                           service_name)


    def create_service(
            coordinator_url: str,
            username: str,
            password: str,
            starburst_password: str,
            common_name_4_cert: str,
            service_name: str) -> None:
        logging.info("Creating service [%s] for Starburst Enterprise [%s]",
                     service_name, coordinator_url)
        service: Dict[str, Any] = configure_service(coordinator_url,
                                                    username,
                                                    starburst_password,
                                                    common_name_4_cert,
                                                    service_name)
        response: requests.models.Response = requests.post(
            url=RANGER_ADDRESS + "/service/public/v2/api/service",
            json=service,
            auth=(username, password),
            verify=False
        )
        assert response.status_code == 200, "Incorrect response for create_service: " + response.text
        logging.info("Service [%s] created successfully", service_name)


    def update_service(
            coordinator_url: str,
            username: str,
            password: str,
            starburst_password: str,
            common_name_4_cert: str,
            service: Any) -> None:
        name: str = service["name"]
        logging.info("Updating service [%s] for Starburst Enterprise [%s], Ranger url: [%s]",
                     name, coordinator_url, RANGER_ADDRESS)
        updated_service: Dict[str, Any] = configure_service(coordinator_url,
                                                            username,
                                                            starburst_password,
                                                            common_name_4_cert,
                                                            name)
        updated_service["tagVersion"] = service["tagVersion"]
        updated_service["policyVersion"] = service["policyVersion"]
        response: requests.models.Response = requests.put(
            url=RANGER_ADDRESS + "/service/public/v2/api/service/" + str(service['id']),
            json=updated_service,
            auth=(username, password),
            verify=False
        )
        assert response.status_code == 200, "Incorrect response for update_service: " + response.text
        logging.info("Service [%s] updated successfully", name)


    def configure_service(
            coordinator_url: str,
            username: str,
            starburst_password: str,
            common_name_4_cert: str,
            service_name: str) -> Dict[str, Any]:
        return {
            "tagVersion": 1,
            "policyVersion": 1,
            "configs": {
                "jdbc.driverClassName": "io.trino.jdbc.TrinoDriver",
                "jdbc.url": coordinator_url,
                "resource-lookup": "true",
                "username": username,
                "password": starburst_password,
                "commonNameForCertificate": common_name_4_cert
            },
            "type": SERVICE_DEFINITION,
            "name": service_name,
            "description": "Created by Starburst Platform auto-configure script, do not modify",
        }


    def config_access_control(config: Any) -> None:
        service_definition_created: bool = False
        for data_source in config["datasources"]:
            service: str = data_source["name"]
            username: str = data_source["username"]
            password: str = data_source["password"]
            url_params = data_source["urlparams"] if str(data_source["urlparams"]) != "None" else ""
            starburst_password: str = data_source["starburstpassword"]
            common_name_4_cert: str = data_source["commonname"]

            coordinator_url: str = "jdbc:trino://{}:{}{}".format(data_source["host"],
                                                                 data_source["port"],
                                                                 url_params)

            create_user(username, password)
            if not service_definition_created:
                create_service_definition(username, password)
                service_definition_created = True
            create_or_update_service(coordinator_url,
                                     username,
                                     password,
                                     starburst_password,
                                     common_name_4_cert,
                                     service)


    def parse_params() -> Namespace:
        parser = ArgumentParser(
            description="Apply Ranger services configuration from config file.")
        parser.add_argument("node_type", choices=["ranger-admin", "ranger-usersync"])
        parser.add_argument(
            "-c",
            "--config",
            default="/config/datasources.yaml",
            help="location of config file, default %(default)s")
        return parser.parse_args()


    def config_ranger(args: Namespace) -> None:
        config: Any = read_manifest(args.config)
        if args.node_type == "ranger-admin":
            config_access_control(config)


    if __name__ == "__main__":
        logging.basicConfig(
            stream=stdout,
            level=logging.INFO,
            format='%(asctime)s %(levelname)s: %(message)s')
        config_ranger(parse_params())
  create-user.sh: "#!/bin/bash\n\nset -euo pipefail\n\nranger_admin_url=\"http://localhost:6080\"\n\nfunction
    usage() {\n\tcat <<EOF\n$(basename $0) [OPTIONS...] <app_user> <app_password>\nIf
    app_user does not exist, create it.\n-l; Set Ranger Admin server url (default:
    ranger_admin_url variable)\n-u; Set Ranger Admin username (default: ranger_username
    variable)\n-p; Set Ranger Admin user password (default: ranger_password variable).
    If password is not given it's asked from the tty.\nEOF\n}\n\nwhile getopts \":l:u:p:h\"
    arg; do\n\tcase $arg in\n\t\tl)\n\t\t\tranger_admin_url=${OPTARG}\n\t\t\t;;\n\t\tu)\n\t\t\tranger_username=${OPTARG}\n\t\t\t;;\n\t\tp)\n\t\t\tranger_password=${OPTARG}\n\t\t\t;;\n\t\th)\n\t\t\tusage\n\t\t\texit
    0\n\t\t\t;;\n\t\t\"\")\n\t\t\tbreak\n\t\t\t;;\n\t\t*)\n\t\t\techo \"Unknown option
    provided ${1:-}\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\tesac\ndone\n\nshift
    $((OPTIND - 1))\n\nif [ $# != 2 ]; then\n\techo \"Invalid arguments.\" >&2\n\tusage\n\texit
    1\nfi\n\nif [ -z \"${ranger_password:-}\" ]; then\n\tread -rsp \"Enter Password:
    \" ranger_password\n\tprintf \"\\n\"\nfi\napp_user=\"${1}\"\napp_password=\"${2}\"\n\ncheck_user()
    {\n\tcurl \\\n\t\t--silent \\\n\t\t--fail \\\n\t\t--insecure \\\n\t\t--output
    /dev/null \\\n\t\t--user \"${app_user}:${app_password}\" \\\n\t\t--header 'Accept:
    application/json' \\\n\t\t\"${ranger_admin_url}/service/xusers/users\"\n}\n\ncreate_user()
    {\n\tcurl \\\n\t\t-X POST \\\n\t\t--silent \\\n\t\t--show-error \\\n\t\t--insecure
    \\\n\t\t--user \"${ranger_username}:${ranger_password}\" \\\n\t\t--header 'Content-Type:
    application/json' \\\n\t\t--data '{\n            \"name\":\"'${app_user}'\",\n
    \           \"firstName\":\"'${app_user}'\",\n            \"lastName\": null,\n
    \           \"emailAddress\" : null,\n            \"description\" : \"Do not change
    password\",\n            \"password\" : \"'${app_password}'\",\n            \"groupIdList\":[],\n
    \           \"status\":1,\n            \"isVisible\":0,\n            \"userRoleList\":
    [ \"ROLE_SYS_ADMIN\" ],\n            \"userSource\": 0\n            }' \\\n\t\t\"${ranger_admin_url}/service/xusers/secure/users\"\n}\n\nif
    check_user; then\n\techo \"User ${app_user} already exists\"\nelse\n\tcreate_user\n\tif
    check_user; then\n\t\techo -e \"\\nUser ${app_user} created\"\n\telse\n\t\techo
    -e \"\\nCannot create user ${app_user}\" >&2\n\t\texit 2\n\tfi\nfi\n"
kind: ConfigMap
metadata:
  annotations:
    meta.helm.sh/release-name: ranger
    meta.helm.sh/release-namespace: default
  creationTimestamp: "2023-05-16T06:45:13Z"
  labels:
    app.kubernetes.io/managed-by: Helm
    name: scripts-configmap
  name: scripts-configmap
  namespace: default
  resourceVersion: "521630"
  uid: 9454272f-60b8-4760-aace-61a5c348a787
